“QIT”
Questions:
搜索阶段耗时主要发生在什么操作上？

Ideas：
引发耗时和内存boom的是candidates太多（尤其是简单情况），那么考虑如何减少不必要的candidates
先找复杂情况，能合一个是一个（数量稀少，基于LUT寻找所有有着共享输入的）
再找简单情况，每找到一定数量的candidates后就先合了再说（还得琢磨如何在一定的candidates集中找到合并数量最多的合并方案）
能否对简单情况和复杂情况采取不同策略？
横向距离标定及横向分区

Tasks：
实验：
为测试复杂情况对应逻辑写简单样例，看看究竟能不能检查出此类合并对
测试不同深度距离限制下的效果差异（关注耗时、合并数量、内存占用等指标）
功能：
根据文件大小不同能采用不同策略（分区/遍历）
具体统计每一步骤耗时，方便定位需要优化的步骤
代码修改：
calculate_new_init()（分类讨论：当存在Absorb情况时，只需根据新的输入信号顺序给出原来6输入LUT的INIT变形）
CanLut6AbsorbLutS() (增加对有着更少位输入信号的LutS的检查逻辑。检查是否存在吸收关系并找出相应selbit)